{"backend_state":"running","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-e97504d2-9f39-4476-bb15-b856b01d7a7f.json","kernel":"sage-9.7","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1701381238514,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1699569864358,"exec_count":3,"id":"cda25e","input":"load(\"quivers.sage\")\ntestQuiver = Quiver(matrix(([0, 5, -3],[-5, 0, 4],[3,-4,0])))\nx = testQuiver.mutate([1])\nprint(x)\ncalculateClusterVariables(testQuiver, [1,2,1])\n","kernel":"sage-9.7","output":{"0":{"name":"stdout","text":"[  0  -5   3]\n[  5   0 -11]\n[ -3  11   0]\n"},"1":{"data":{"text/plain":"[x1*x3**52/(x2**5 + x3**3) + (x1**25*x3**55 + 5*x1**20*x2**25*x3**44 + 25*x1**20*x2**20*x3**47 + 50*x1**20*x2**15*x3**50 + 50*x1**20*x2**10*x3**53 + 25*x1**20*x2**5*x3**56 + 5*x1**20*x3**59 + 10*x1**15*x2**50*x3**33 + 100*x1**15*x2**45*x3**36 + 450*x1**15*x2**40*x3**39 + 1200*x1**15*x2**35*x3**42 + 2100*x1**15*x2**30*x3**45 + 2520*x1**15*x2**25*x3**48 + 2100*x1**15*x2**20*x3**51 + 1200*x1**15*x2**15*x3**54 + 450*x1**15*x2**10*x3**57 + 100*x1**15*x2**5*x3**60 + 10*x1**15*x3**63 + 10*x1**10*x2**75*x3**22 + 150*x1**10*x2**70*x3**25 + 1050*x1**10*x2**65*x3**28 + 4550*x1**10*x2**60*x3**31 + 13650*x1**10*x2**55*x3**34 + 30030*x1**10*x2**50*x3**37 + 50050*x1**10*x2**45*x3**40 + 64350*x1**10*x2**40*x3**43 + 64350*x1**10*x2**35*x3**46 + 50050*x1**10*x2**30*x3**49 + 30030*x1**10*x2**25*x3**52 + 13650*x1**10*x2**20*x3**55 + 4550*x1**10*x2**15*x3**58 + 1050*x1**10*x2**10*x3**61 + 150*x1**10*x2**5*x3**64 + 10*x1**10*x3**67 + 5*x1**5*x2**100*x3**11 + 100*x1**5*x2**95*x3**14 + 950*x1**5*x2**90*x3**17 + 5700*x1**5*x2**85*x3**20 + 24225*x1**5*x2**80*x3**23 + 77520*x1**5*x2**75*x3**26 + 193800*x1**5*x2**70*x3**29 + 387600*x1**5*x2**65*x3**32 + 629850*x1**5*x2**60*x3**35 + 839800*x1**5*x2**55*x3**38 + 923780*x1**5*x2**50*x3**41 + 839800*x1**5*x2**45*x3**44 + 629850*x1**5*x2**40*x3**47 + 387600*x1**5*x2**35*x3**50 + 193800*x1**5*x2**30*x3**53 + 77520*x1**5*x2**25*x3**56 + 24225*x1**5*x2**20*x3**59 + 5700*x1**5*x2**15*x3**62 + 950*x1**5*x2**10*x3**65 + 100*x1**5*x2**5*x3**68 + 5*x1**5*x3**71 + x2**125 + 25*x2**120*x3**3 + 300*x2**115*x3**6 + 2300*x2**110*x3**9 + 12650*x2**105*x3**12 + 53130*x2**100*x3**15 + 177100*x2**95*x3**18 + 480700*x2**90*x3**21 + 1081575*x2**85*x3**24 + 2042975*x2**80*x3**27 + 3268760*x2**75*x3**30 + 4457400*x2**70*x3**33 + 5200300*x2**65*x3**36 + 5200300*x2**60*x3**39 + 4457400*x2**55*x3**42 + 3268760*x2**50*x3**45 + 2042975*x2**45*x3**48 + 1081575*x2**40*x3**51 + 480700*x2**35*x3**54 + 177100*x2**30*x3**57 + 53130*x2**25*x3**60 + 12650*x2**20*x3**63 + 2300*x2**15*x3**66 + 300*x2**10*x3**69 + 25*x2**5*x3**72 + x3**75)/(x1**24*x2**10 + x1**24*x2**5*x3**3),\n x3**11/x2 + (x2**25 + 5*x2**20*x3**3 + 10*x2**15*x3**6 + 10*x2**10*x3**9 + 5*x2**5*x3**12 + x3**15)/(x1**5*x2),\n x3]"},"exec_count":3}},"pos":11,"start":1699569862288,"state":"done","type":"cell"}
{"cell_type":"code","end":1699569906425,"exec_count":4,"id":"653d33","input":"import sympy\ntest1 = sympy.symbols('x1')\ntest2 = sympy.symbols('x2')\ntest3 = sympy.symbols('x3')\n\ntest2 = test2**5\ntest3 = test3 ** 3\n\nfinalTest = (test2 + test3)/((test2+test3)/test1)\nfinalTest = sympy.simplify(finalTest)\nprint(finalTest)","kernel":"sage-9.7","output":{"0":{"name":"stdout","text":"x1\n"}},"pos":12,"start":1699569906418,"state":"done","type":"cell"}
{"cell_type":"code","end":1701381203721,"exec_count":1,"id":"5c7d55","input":"load(\"quivers.sage\")\n\nM = matrix(([0, -5, 3],[5, 0, -4],[-3,4,0]))\nN = block_matrix([[M,identity_matrix(3)]])\nQ = Quiver(M)\nQ.show()\nmutSeq = [1,2,2,3,2,1,2,3,2,1,2,3,2]\nprint(Q.cMatrix(mutSeq))\nprint(mMutation(N,mutSeq))","kernel":"sage-9.7","output":{"0":{"data":{"image/png":"baca80db884bca4db739165b10e8916517bcf408","text/plain":"Graphics object consisting of 10 graphics primitives"}},"1":{"name":"stdout","text":"[                                 -3819445223276342591352                                   -115866322520643395972                                  -1274529530377162309117]\n[                      -141216696566093924424234654251400                        -28241653603750067241508906101019                       -308090793951777823115865638498040]\n[ 4984052780900683229941612992265713086634548816955476743   996751061338735788434543337000689399595212281742936280 10873648907702465108531930455924827895567274054182258221]\n[                                                                             0                        2533917132621017378605539375703363723641970129629855772 -89431186527584639654539206243117060579702165346034759072295462610711834675555|                                                       -3819445223276342591352                                                         -115866322520643395972                                                        -1274529530377162309117]\n[                      -2533917132621017378605539375703363723641970129629855772                                                                              0                                                        35293650836592026771371|                                            -141216696566093924424234654251400                                              -28241653603750067241508906101019                                             -308090793951777823115865638498040]\n[ 89431186527584639654539206243117060579702165346034759072295462610711834675555                                                       -35293650836592026771371                                                                              0|                       4984052780900683229941612992265713086634548816955476743                         996751061338735788434543337000689399595212281742936280                       10873648907702465108531930455924827895567274054182258221]\n"}},"pos":8,"start":1701381198965,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":0,"id":"712507","input":"","pos":14,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":13,"id":"624825","input":"load(\"quivers.sage\")\ndir(Quiver)","output":{"0":{"data":{"text/plain":"['__add__',\n '__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n '_keyVertices',\n '_pointOfReturnFork',\n '_preForkVertices',\n '_tipVertices',\n '_wingVertices',\n 'abundantTriangularExtension',\n 'arrow',\n 'cMatrix',\n 'digraph',\n 'disjointUnion',\n 'forklessPart',\n 'framedQuiver',\n 'frozenVertices',\n 'fullSubquiver',\n 'greens',\n 'hasFiniteForklessPart',\n 'hasFrozen',\n 'hasSinks',\n 'hasSources',\n 'hasZeroForklessPart',\n 'isAbundant',\n 'isAbundantAcyclic',\n 'isAcyclic',\n 'isComplete',\n 'isFork',\n 'isIsomorphicTo',\n 'isKey',\n 'isLabeledCycle',\n 'isPreFork',\n 'isReddeningSequence',\n 'isTip',\n 'isWing',\n 'isomorphicQuiver',\n 'mutableVertices',\n 'mutate',\n 'neighborhood',\n 'oppositeQuiver',\n 'plot',\n 'pointOfReturn',\n 'predecessor',\n 'preserveOptions',\n 'principalQuiver',\n 'reds',\n 'reflections',\n 'show',\n 'sinks',\n 'size',\n 'sizeMutable',\n 'sources',\n 'stopover',\n 'subquiverRemoveVertex',\n 'successor',\n 'triangularExtension',\n 'vertices']"},"exec_count":13,"output_type":"execute_result"}},"pos":1,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":14,"id":"5eab9b","input":"# Code block that loads the file and initializes all the variables we'll need\n# Testing only on rank 4 for now, as that will allow us to look at all the types of quivers we need\nn = 4\nabundantM = matrix(([0,2,3,4],[-2,0,5,6],[-3,-5,0,7],[-4,-6,-7,0])) # rank 4 abundant acyclic\ncyclicM = matrix(([0,3,-3,3],[-3,0,3,3],[3,-3,0,3],[-3,-3,-3,0])) # rank 4 mutation-cyclic\nrank3test = [2,1,3,2,1,3,2,1,2,1,3,4,2,4] # Example mutation\nrank3back = [2,2,3,3,1,1,2,3] # Is not empty mutation\nrank3empty = []\nrank3equiv = [2,2,3,3,1,1,3,3,2,2] # Equivalent to empty matrix\n\nmatrices = [abundantM, cyclicM] # list of matrices to try\nC = identity_matrix(n)\nmatrices = matrices\nframedMatricesCols = [block_matrix([[B,C]]) for B in matrices]\nframedMatricesRows = [block_matrix([[B],[C]]) for B in matrices]\nmutations = [rank3test,rank3back,rank3empty,rank3equiv] # list of mutation sequences to try\nrowOptions = [\"cols\", \"rows\"] # Options for n x 2n or 2n x n of class\norientOptions = [\"positive\", \"negative\"] # Options for orientation\n\nQ = Quiver() # Initializes the quiver on 1 vertex\nprint(Q)\n\nmutationWorks = True # Variable to test if mutation works\nverticesWorks = True # Variable to test if code involving vertices works","output":{"0":{"name":"stdout","output_type":"stream","text":"[0]\n"}},"pos":2,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":15,"id":"93caca","input":"# TESTS MUTATION\n\nfor M in matrices:\n    for row in rowOptions:\n        for orient in orientOptions:\n            Q = Quiver(M,rowsOrCols = row, orientation = orient)\n            \n            if Q.matrix != M:\n                print(\"Matrix was not constructed for:\\n\", M, row, orient)\n                print(Q)\n                continue\n            \n            for w in mutations:\n                N = mMutation(M,w)\n                P = Q.mutate(w)\n                R = Quiver(N, rowsOrCols = row, orientation = orient)\n                if R != P:\n                    print(\"---------------------\")\n                    print(\"Mutation fails for: \")\n                    print(\"Matrix: \", M)\n                    print(\"Mutation: \", w)\n                    print(\"rowsOrCols: \", row)\n                    print(\"orientation: \", orient)\n                    mutationWorks = False\n                \nfor M in framedMatricesRows:\n    for orient in orientOptions:\n        Q = Quiver(M,rowsOrCols = \"rows\", orientation = orient)\n        \n        if Q.matrix != M:\n            print(\"Matrix was not constructed for:\\n\", M, row, orient)\n            print(Q)\n            continue\n\n        for w in mutations:\n            N = mMutation(M,w)\n            P = Q.mutate(w)\n            if N != P.matrix:\n                print(\"---------------------\")\n                print(\"Mutation fails for: \")\n                print(\"Matrix: \", M)\n                print(\"Mutation: \", w)\n                print(\"rowsOrCols: \", row)\n                print(\"orientation: \", orient)\n                mutationWorks = False\n        \nfor M in framedMatricesCols:\n    for orient in orientOptions:\n        Q = Quiver(M,rowsOrCols = \"cols\", orientation = orient)\n        \n        if Q.matrix != M:\n            print(\"Matrix was not constructed for:\\n\", M, row, orient)\n            print(Q)\n            continue\n\n        for w in mutations:\n            N = mMutation(M,w)\n            P = Q.mutate(w)\n            if N != P.matrix:\n                print(\"---------------------\")\n                print(\"Mutation fails for: \")\n                print(\"Matrix: \", M)\n                print(\"Mutation: \", w)\n                print(\"rowsOrCols: \", row)\n                print(\"orientation: \", orient)\n                mutationWorks = False\n                \nif mutationWorks:\n    print(\"Mutation works as expected\")\nelse:\n    print(\"Something Broke\")\n                ","output":{"0":{"name":"stdout","output_type":"stream","text":"Mutation works as expected\n"}},"pos":3,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":16,"id":"ce10fa","input":"# TESTS SINK/SOURCE/STOPOVER FUNCTIONS\n\nfor M in matrices:\n    for row in rowOptions:\n        for orient in orientOptions:\n            Q = Quiver(M,rowsOrCols = row, orientation = orient)\n            \n            if Q.matrix != M:\n                print(\"Matrix was not constructed for:\\n\", M, row, orient)\n                print(Q)\n                continue\n            \n            for w in mutations:\n                if orient == \"negative\":\n                    N = mMutation(-M,w)\n                else:\n                    N = mMutation(M,w)\n                P = Q.mutate(w)\n                sinks = tuple(sinkVertices(N))\n                sources = tuple(sourceVertices(N))\n                stover = [tuple(stopover(i,N,j)) for i in [1..n] for j in [1..n] if i != j]\n                stoverP = [P.stopover(i,j) for i in [1..n] for j in [1..n] if i != j]\n                if sinks != P.sinks or sources != P.sources or stover != stoverP:\n                    print(\"---------------------\")\n                    print(\"Fails for: \")\n                    print(\"Matrix: \\n\", M)\n                    print(\"Mutation: \", w)\n                    print(\"Mutated Matrix: \\n\", N)\n                    print(\"rowsOrCols: \", row)\n                    print(\"orientation: \", orient)\n                    print(sinks, P.sinks)\n                    print(sources,P.sources)\n                    print(stover, stoverP)\n                    verticesWorks = False\n                    \nfor M in framedMatricesRows:\n    for orient in orientOptions:\n        Q = Quiver(M,rowsOrCols = \"rows\", orientation = orient)\n        if orient == \"negative\":\n            N = mMutation(-M,w)\n        else:\n            N = mMutation(M,w)\n        P = Q.mutate(w)\n        stover = [tuple(stopover(i,N,j)) for i in [1..n] for j in [1..n] if i != j]\n        stoverP = [P.stopover(i,j) for i in [1..n] for j in [1..n] if i != j]\n        if stover != stoverP:\n            print(\"---------------------\")\n            print(\"Fails for: \")\n            print(\"Matrix: \\n\", M)\n            print(\"Mutation: \", w)\n            print(\"Mutated Matrix: \\n\", N)\n            print(\"rowsOrCols: \", row)\n            print(\"orientation: \", orient)\n            verticesWorks = False\n        \nfor M in framedMatricesCols:\n    for orient in orientOptions:\n        Q = Quiver(M,rowsOrCols = \"cols\", orientation = orient)\n        if orient == \"negative\":\n            N = mMutation(-M,w)\n        else:\n            N = mMutation(M,w)\n        P = Q.mutate(w)\n        stover = [tuple(stopover(i,N,j)) for i in [1..n] for j in [1..n] if i != j]\n        stoverP = [P.stopover(i,j) for i in [1..n] for j in [1..n] if i != j]\n        if stover != stoverP:\n            print(\"---------------------\")\n            print(\"Fails for: \")\n            print(\"Matrix: \\n\", M)\n            print(\"Mutation: \", w)\n            print(\"Mutated Matrix: \\n\", N)\n            print(\"rowsOrCols: \", row)\n            print(\"orientation: \", orient)\n            verticesWorks = False\n                \nif verticesWorks:\n    print(\"Functions work as intended\")\nelse:\n    print(\"Something Broke\")","output":{"0":{"name":"stdout","output_type":"stream","text":"Functions work as intended\n"}},"pos":4,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":17,"id":"0e9e7f","input":"load(\"quivers.sage\")\n\n## think the 1 forkless part due to iso morphism are special cases of something\n## idk what I was trying to show here, ignore this\nP = Quiver(matrix(([0, 3, -4,-2],[-3, 0 , 5,5],[4,-5,0,2],[2,-5,-2,0])))\nP.getLinearOrdering()","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 1  1  1]\n[ 0  5  5]\n[-5  0  2]\n[-5 -2  0]\n"},"1":{"data":{"text/plain":"[1, 4, 3, 2]"},"exec_count":17,"output_type":"execute_result"}},"pos":10,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":17,"id":"d33239","input":"for M in matrices:\n    for row in rowOptions:\n        for orient in orientOptions:\n            Q = Quiver(M,rowsOrCols = row, orientation = orient)\n            \n            ","pos":5,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":18,"id":"d29151","input":"[1..3]","output":{"0":{"data":{"text/plain":"[1, 2, 3]"},"exec_count":18,"output_type":"execute_result"}},"pos":6,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":19,"id":"7976bb","input":"Q.hasSinks","output":{"0":{"data":{"text/plain":"False"},"exec_count":19,"output_type":"execute_result"}},"pos":7,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"9de0a6","input":"load(\"quivers.sage\")\n\n## think the 1 forkless part due to iso morphism are special cases of something\n## idk what I was trying to show here, ignore this\nP = Quiver(matrix(([0, 3, -3],[-2, 0, 2],[2,-2,0])))\nprint('\\n', P.reflections([2,3,2,1,2]))\nprint('\\n', P.reflectionsCanceled([2,3,2,1,2]))\nP.calculateLMatrix([2,3,2,1,2], [3,2,1])\n","output":{"0":{"name":"stdout","output_type":"stream","text":"\n [Quiver([ 0 -3  9| 5 18 15]\n[ 2  0 -4|-2 -7 -6]\n[-6  4  0| 0 -2 -1]), '3,2,1,2,3,2,3,2,1,2,3,3,2,1,2,3,3,2,1,2,3,2,3,2,1,2,3', '3,2,1,2,3,2,3,2,1,2,3', '2,3,2']\n\n [Quiver([ 0 -3  9| 5 18 15]\n[ 2  0 -4|-2 -7 -6]\n[-6  4  0| 0 -2 -1]), '3,2,1,2,3,2,3,2,1,2,3,2,3,2,1,2,3', '3,2,1,2,3,2,3,2,1,2,3', '2,3,2']\n"},"1":{"data":{"text/plain":"[\nQuiver([ 0 -3  9| 5 18 15]  [ -5 -18 -15]\n[ 2  0 -4|-2 -7 -6]         [  2   7   6]\n[-6  4  0| 0 -2 -1])      , [  0   2   1]\n]"},"exec_count":3,"output_type":"execute_result"}},"pos":9,"scrolled":true,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":42,"id":"8763ed","input":"CV=[]\nfor i in range(1,4):\n    CV.append(sympy.symbols('x'+str(i)))\nprint(CV)","output":{"0":{"name":"stdout","output_type":"stream","text":"[x1, x2, x3]\n"}},"pos":13,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"62b0e1","input":"Jupyter worksheet to make sure the code works correctly\n\n","pos":0,"state":"done","type":"cell"}
{"id":0,"time":1701381151370,"type":"user"}
{"last_load":1699564655420,"type":"file"}