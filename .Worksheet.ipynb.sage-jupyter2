{"backend_state":"ready","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-548bb2d9-e805-485a-a40e-f19138c13c00.json","kernel":"sage-9.7","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1710822421254,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"56b94e","input":"## load(\"quivers.sage\")\n\nE = {1 : {2: \"3\"}}\nprint(E)\nprint(E.get(1, False))\nprint(E.get(2, False))\nE[2] = {4: \"5\"}\nprint(E)\nE[1].update({6:\"7\"})\nprint(E)\nG = Graph(E, weighted=True)\nG.show(edge_labels=True)\n\n","output":{"0":{"name":"stdout","output_type":"stream","text":"{1: {2: '3'}}\n{2: '3'}\nFalse\n{1: {2: '3'}, 2: {4: '5'}}\n{1: {2: '3', 6: '7'}, 2: {4: '5'}}\n"},"1":{"data":{"image/png":"4f2c47ccdd34056ad0d98ee7befc054473ef5d04","text/plain":"Graphics object consisting of 11 graphics primitives"},"exec_count":1,"output_type":"execute_result"}},"pos":0,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"a9b63c","input":"\nload(\"quivers.sage\")\nM = matrix(([0,2,2],[-2,0,2],[-2,-2,0]))\nn = 3\nw = [2,1,3]\nu = [2,3]\nv = w[::-1] + [1,2,3] + w\ns = u[::-1] + [1,2,3] + u\ns = [i + n for i in s]\nQ = Quiver(M)\nA = Q.mutate(w)\nB = Q.mutate(u)\nA.show()\nB.show()\nT = A.abundantTriangularExtension(B)\nTPrime = T.mutate(v)\nTTilde = T.mutate(v+s)\nprint(v+s)\nT.show()\nTPrime.show()\nTTilde.show()\nprint(T == TTilde)","pos":2,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"507be3","input":"load(\"quivers.sage\")\nQ = Quiver(matrix(([0,2,-3],[-2,0,3],[3,-3,0])))\nw = [2,1,2,3,2,1,3,2,1,2,3]\nm = len(w)\nv = w[::-1]\nprint(Q)\nQ = Q.mutate(w)\nP = Quiver() # Should be the default quiver on one vertex\nT = Q.abundantTriangularExtension(P)\nfor i in [1..len(u)]:\n    print(\"-----------------\")\n    u = v[:i]\n    print(u)\n    R = T.mutate(u)\n    print(R)\nprint(T)\nT.show()\n\nG = T.forklessPart(8)\n\nG.show(edge_labels=True, vertex_labels=False) # Draws the labelled forkless mutation graph for our quiver \ncount = 0\nfor P in G.vertices(sort = False):\n    if P.hasSources or P.hasSinks:\n        count += 1\n        \n    for v in P.vertices:\n        R = P.subquiverRemoveVertex(v)\n        if not R.isFork and not R.isAbundantAcyclic and R != Q and R != Q.oppositeQuiver():\n            print(\"The following quiver is interesting: \")\n            P.show()\n            print(P)\n            print(R)\n            break\n            \n        \nprint(\"Number of non-forks, \", G.order())\nprint(\"Number of non-forks with sinks/sources, \", count)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0  2 -3]\n[-2  0  3]\n[ 3 -3  0]\n"},"1":{"ename":"NameError","evalue":"name 'u' is not defined","output_type":"error","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[1;32m/home/user/FiniteNonForks/Worksheet.ipynb Cell 2\u001b[0m line \u001b[0;36m<cell line: 10>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      <a href='vscode-notebook-cell://cocalc.com/home/user/FiniteNonForks/Worksheet.ipynb#W1sdnNjb2RlLXJlbW90ZQ%3D%3D?line=7'>8</a>\u001b[0m P \u001b[39m=\u001b[39m Quiver() \u001b[39m# Should be the default quiver on one vertex\u001b[39;00m\n\u001b[1;32m      <a href='vscode-notebook-cell://cocalc.com/home/user/FiniteNonForks/Worksheet.ipynb#W1sdnNjb2RlLXJlbW90ZQ%3D%3D?line=8'>9</a>\u001b[0m T \u001b[39m=\u001b[39m Q\u001b[39m.\u001b[39mabundantTriangularExtension(P)\n\u001b[0;32m---> <a href='vscode-notebook-cell://cocalc.com/home/user/FiniteNonForks/Worksheet.ipynb#W1sdnNjb2RlLXJlbW90ZQ%3D%3D?line=9'>10</a>\u001b[0m \u001b[39mfor\u001b[39;00m i \u001b[39min\u001b[39;00m (ellipsis_range(Integer(\u001b[39m1\u001b[39m),\u001b[39mEllipsis\u001b[39m,\u001b[39mlen\u001b[39m(u))):\n\u001b[1;32m     <a href='vscode-notebook-cell://cocalc.com/home/user/FiniteNonForks/Worksheet.ipynb#W1sdnNjb2RlLXJlbW90ZQ%3D%3D?line=10'>11</a>\u001b[0m     \u001b[39mprint\u001b[39m(\u001b[39m\"\u001b[39m\u001b[39m-----------------\u001b[39m\u001b[39m\"\u001b[39m)\n\u001b[1;32m     <a href='vscode-notebook-cell://cocalc.com/home/user/FiniteNonForks/Worksheet.ipynb#W1sdnNjb2RlLXJlbW90ZQ%3D%3D?line=11'>12</a>\u001b[0m     u \u001b[39m=\u001b[39m v[:i]\n","\u001b[0;31mNameError\u001b[0m: name 'u' is not defined"]}},"pos":1,"scrolled":true,"type":"cell"}
{"cell_type":"code","id":"014b17","input":"load(\"quivers.sage\")\nM = matrix(([0,3,4],[-3,0,5],[-4,-5,0]))\nQ = Quiver(M)\nP = Q.isomorphicQuiver([1,3,2])\nprint(Q)\nprint(\"-\" * 20)\nprint(P)","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0  3  4]\n[-3  0  5]\n[-4 -5  0]\n--------------------\n[ 0  4  3]\n[-4  0 -5]\n[-3  5  0]\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","id":"0517bf","input":"## issue, when looking if all forks with 1 forkless part were in my form, I found this, a 1 forkless part quiver not akin to the ones I have generated\n\n## shows that fundementa idea of having all subquivers of 3 nodes be n-forkless part falls apart besides for 0 forkless,\n## looking into construction process for these, I think it can be a generalization of \nload(\"quivers.sage\")\n\nn=5\nm=6\n\nQ = Quiver(matrix(([0,n,n,m],\n                  [-n,0,m,n],\n                  [-n,-m,0,-n],\n                  [-m,-n,n,0])))\n\n\nprint(isFork(Q.matrix))\ndisplayQuiver(Q.matrix)\n\nfor i in [1..4]:\n    if not(isFork(Q.mutate([i]).matrix)):\n        print(i)\n\nQmu1 = Q.mutate([1]).matrix\nQmu1 = swapNodes(Qmu1, 1,2)\nQmu1 = swapNodes(Qmu1, 2,4)\nQmu1 = swapNodes(Qmu1, 3,4)\nprint(Qmu1 == Q.matrix)\n\n\nQmu3 = Q.mutate([3]).matrix\nQmu3 = swapNodes(Qmu3, 1,3)\nQmu3 = swapNodes(Qmu3, 2,3)\nQmu3 = swapNodes(Qmu3, 3,4)\nprint(Qmu3 == Q.matrix)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"0\n"},"1":{"data":{"image/png":"64734e7cc2e9048eee56e3e675c16064917e94e5","text/plain":"Graphics object consisting of 17 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"2":{"name":"stdout","output_type":"stream","text":"1\n3\nTrue\nTrue\n"}},"pos":10,"type":"cell"}
{"cell_type":"code","id":"1bb94c","input":"","pos":15,"type":"cell"}
{"cell_type":"code","id":"1c03b2","input":"## generalization for the above construction process\nload(\"quivers.sage\")\n\n## max nodes + 3 at end\nmaxNodes = 20\n\n## n and m as defined above\nn = 3\nm = 2\nQ = Quiver(matrix(([0,n,-1*m],[-1*n,0,n],[m,-1*n,0])))\nQprime = Quiver(constructionOf1ForklessPart(Q.matrix, n))\n\nfor meaningless in range(maxNodes):\n    ## count number of nonforks (should be 0 when m>2 and 2 when m=2)\n    print(isFork(Qprime.matrix))\n    nonforks = []\n    for i in range(1,Qprime.matrix.ncols()):\n        if not isFork(Qprime.mutate([i]).matrix):\n            nonforks.append([Qprime.mutate([i]).matrix,i])\n    \n    # test number of non forks\n    if(len(nonforks) == 2):\n        # when m=2 and thus mu1 and mu2 (i and k) must be isomorphic\n        isoQ = swapNodes(nonforks[0][0], nonforks[0][1], nonforks[1][1])\n        print(\"Equal Quivers:\", isoQ == Qprime.matrix)\n    else:\n        # when m>2 and thus all mutations should be forks\n        print(len(nonforks) == 0)\n    \n    # getting the next quiver w/ the construction process\n    Qprime = Quiver(constructionOf1ForklessPart(Qprime.matrix, n))","output":{"0":{"name":"stdout","output_type":"stream","text":"0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\nTrue\n0\n"},"1":{"name":"stdout","output_type":"stream","text":"True\n0\nTrue\n0\nTrue\n0\n"},"2":{"name":"stdout","output_type":"stream","text":"True\n0\nTrue\n0\n"},"3":{"name":"stdout","output_type":"stream","text":"True\n0\n"},"4":{"name":"stdout","output_type":"stream","text":"True\n0\n"},"5":{"name":"stdout","output_type":"stream","text":"True\n0\n"},"6":{"name":"stdout","output_type":"stream","text":"True\n0\n"},"7":{"name":"stdout","output_type":"stream","text":"True\n0\n"},"8":{"name":"stdout","output_type":"stream","text":"True\n"}},"pos":8,"type":"cell"}
{"cell_type":"code","id":"7e4889","input":"load(\"quivers.sage\")\nM = matrix(([0,3,5],[-3,0,4],[-5,-4,0]))\nQprime = Quiver(M)\nw = [2,3,1]\nwInverse = [1,3,2]\nQ = Qprime.mutate(w)\ndisplayQuiver(Qprime.matrix)\ndisplayQuiver(Q.matrix)\n\nP = Quiver(matrix(([0,-65,17,2],[65,0,-1101,2],[-17,1101,0,2],[-2,-2,-2,0])))\ndisplayQuiver(P.matrix)\n\n\nP1 = P.mutate(wInverse)\nP2 = P1.mutate([1,2,3])\nP3 = P2.mutate(w)\nP4 = P3.mutate([4])\n\ndisplayQuiver(P4.matrix)\n\n## I thought I had a counter example but I did not as I had it as a source not a sink. Somehow it ruins it if source, I wonder why\n## now have example of prop 3.8","output":{"0":{"data":{"image/png":"f226cc16f625ce7054e4486adbaafd74c1195a50","text/plain":"Graphics object consisting of 10 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"1":{"data":{"image/png":"fa6f2f8de71766d30557bffc2cd5acd3ac2728f6","text/plain":"Graphics object consisting of 10 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"2":{"data":{"image/png":"f04f2be1a44951fbe5c1e063c2e3061c1edec6dc","text/plain":"Graphics object consisting of 17 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"3":{"data":{"image/png":"463d91d9cdb489ec5047f253bc7dcc7b5519ee75","text/plain":"Graphics object consisting of 17 graphics primitives"},"exec_count":0,"output_type":"execute_result"}},"pos":6,"type":"cell"}
{"cell_type":"code","id":"90a0fc","input":"load(\"quivers.sage\")\n## trying to make different cyclic 1 forkless part\n\nn = 5\nm = 3\nQ = Quiver(matrix(([0, n,-m,-n],\n                   [-n,0, n,-m],\n                   [m,-n, 0, n],\n                   [n, m,-n, 0])))\n\nprint(isFork(Q.matrix))\nprint(isFork(Q.mutate([1]).matrix))\nprint(isFork(Q.mutate([2]).matrix))\nprint(isFork(Q.mutate([3]).matrix))\nprint(isFork(Q.mutate([4]).matrix))\nprint() ## for spacing\n\n## trying to make even odder one\nn = 5\nm = 3\nmp = 4\nQ = Quiver(matrix(([0, n,-m, -n],\n                   [-n,0, n,-mp],\n                   [m,-n, 0,  n],\n                   [n,mp,-n,  0])))\n\nprint(isFork(Q.matrix))\nprint(isFork(Q.mutate([1]).matrix))\nprint(isFork(Q.mutate([2]).matrix))\nprint(isFork(Q.mutate([3]).matrix))\nprint(isFork(Q.mutate([4]).matrix))\nprint()\n\n## thus the construction process definately does not work to get ALL 1 forkless part quivers\n\n## Trying one of 5 nodes\n## not working like I'd want to\nn = 5\nm = 3\nQ = Quiver(matrix(([0, n,-m,-n],\n                   [-n,0, n,-m],\n                   [m,-n, 0, n],\n                   [n, m,-n, 0])))\nQ = Quiver(constructionOf1ForklessPart(Q.matrix, n))\n\nprint(isFork(Q.matrix))\nprint(isFork(Q.mutate([1]).matrix))\nprint(isFork(Q.mutate([2]).matrix))\nprint(isFork(Q.mutate([3]).matrix))\nprint(isFork(Q.mutate([4]).matrix))\nprint(isFork(Q.mutate([5]).matrix))\nprint() ## for spacing\n\n## attempt with 6\nn = 5\nm = 3\nQ = Quiver(matrix(([0, n,-m,-n,n,-n],\n                   [-n,0, n,-m,-n,n],\n                   [m,-n, 0, n,-n,n],\n                   [n, m,-n, 0,n,-n],\n                   [-n,n,n,-n,0,-m],\n                   [n,-n,-n,n,m,0])))\n\nprint(Q.matrix)\nprint(isFork(Q.matrix))\nprint(isFork(Q.mutate([1]).matrix))\nprint(isFork(Q.mutate([2]).matrix))\nprint(isFork(Q.mutate([3]).matrix))\nprint(isFork(Q.mutate([4]).matrix))\nprint(isFork(Q.mutate([5]).matrix))\nprint(isFork(Q.mutate([6]).matrix))\nprint() ## for spacing\n\n## uh oh","output":{"0":{"name":"stdout","output_type":"stream","text":"0\n1\n2\n3\n4\n\n0\n1\n2\n3\n4\n\n0\n1\n0\n3\n4\n0\n\n[ 0  5 -3 -5  5 -5]\n[-5  0  5 -3 -5  5]\n[ 3 -5  0  5 -5  5]\n[ 5  3 -5  0  5 -5]\n[-5  5  5 -5  0 -3]\n[ 5 -5 -5  5  3  0]\n0\n1\n2\n3\n4\n5\n6\n\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","id":"991017","input":"## playing with ideas of a construction process for quivers with 1 forkless part\nload(\"quivers.sage\")\n\n#Q is a 3 node quiver me to 1 non fork, as defined in lem 3.6 s.t. any mutation on Q leads to a fork\n# works well when m > 2 as all mutations are forks. Should still work for m = 2 as forks should be isomorphic to Q\nn = 5\nm = 4\nQ = Quiver(matrix(([0,n,-1*m],[-1*n,0,n],[m,-1*n,0])))\ndisplayQuiver(Q.matrix)\nprint() # just to seperate quiver images\n\n# attach a node l s.t. Qprime's 3 node subquivers are of same form as one of the 3 node 1 forkless part, with m and n as defined in original 3 fork\nQprime = Quiver(matrix(([0,n,-1*m,n],\n                        [-1*n,0,n,-1*n],\n                        [m,-1*n,0,-1*n],\n                        [-1*n,n,n,0])))\ndisplayQuiver(Qprime.matrix)\nprint(Qprime.matrix == constructionOf1ForklessPart(Q.matrix, n))\n\nprint(isFork(Qprime.matrix)) ## still non fork, as expected\n\nnonforks = []\nfor i in range(1,5):\n    if not isFork(Qprime.mutate([i]).matrix):\n        nonforks.append([Qprime.mutate([i]).matrix,i])\n\nif len(nonforks) == 0:\n    print(\"Qprime only nonfork\")\n\nfor i in nonforks:\n    print(\"Mutation at \", i[1], \":\")\n    print(i[0])\n\nif(len(nonforks) == 2):\n    isoQ = swapNodes(nonforks[0][0], nonforks[0][1], nonforks[1][1])\n    print(\"Equal Quivers:\", isoQ == Qprime.matrix)\n    \n# works for 3 to 4 node, try 4 to 5\nQdprime = Quiver(matrix(([0,n,-1*m,n,n],\n                         [-1*n,0,n,-1*n,n],\n                         [m,-1*n,0,-1*n,-1*n],\n                         [-1*n,n,n,0,n],\n                         [-1*n,-1*n,n,-1*n,0])))\nprint(isFork(Qdprime.matrix))\n\nnonforks = []\nfor i in range(1,6):\n    if not isFork(Qdprime.mutate([i]).matrix):\n        nonforks.append([Qdprime.mutate([i]).matrix,i])\n\nif len(nonforks) == 0:\n    print(\"Qdprime only nonfork\")\n\nfor i in nonforks:\n    print(\"Mutation at \", i[1], \":\")\n    print(i[0])\n    \nif(len(nonforks) == 2):\n    isoQ = swapNodes(nonforks[0][0], nonforks[0][1], nonforks[1][1])\n    print(\"Equal Quivers:\", isoQ == Qdprime.matrix)\n    \n# trying for 5 to 6, if works assumed general n -> n+1\nQtprime = Quiver(matrix(([0,n,-1*m,n,n,n],\n                         [-1*n,0,n,-1*n,n,-1*n],\n                         [m,-1*n,0,-1*n,-1*n,-1*n],\n                         [-1*n,n,n,0,n,-1*n],\n                         [-1*n,-1*n,n,-1*n,0,-1*n],\n                         [-1*n,n,n,n,n,0])))\n# displayQuiver(Qtprime.matrix) # looks bad so I removed the line\nprint(isFork(Qtprime.matrix))\n\nnonforks = []\nfor i in range(1,6):\n    if not isFork(Qtprime.mutate([i]).matrix):\n        nonforks.append([Qtprime.mutate([i]).matrix,i])\n\nif len(nonforks) == 0:\n    print(\"Qdprime only nonfork\")\n\nfor i in nonforks:\n    print(\"Mutation at \", i[1], \":\")\n    print(i[0])\n    \nif(len(nonforks) == 2):\n    isoQ = swapNodes(nonforks[0][0], nonforks[0][1], nonforks[1][1])\n    print(\"Equal Quivers:\", isoQ == Qtprime.matrix)\n","output":{"0":{"data":{"image/png":"22f2d46ece132cc7c30e56a374aa9f26439b1805","text/plain":"Graphics object consisting of 10 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"\n"},"2":{"data":{"image/png":"e48a10dc1d6bb383245a0fccc301c5b63f9a709f","text/plain":"Graphics object consisting of 17 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"3":{"name":"stdout","output_type":"stream","text":"True\n0\nQprime only nonfork\n0\nQdprime only nonfork\n0\nQdprime only nonfork\n"}},"pos":7,"type":"cell"}
{"cell_type":"code","id":"a2fee2","input":"load(\"quivers.sage\")\n\nn = 2\nmaxNodes = 20\n\nQ = Quiver(matrix((\n    [ 0, n,n],\n    [-n, 0,n],\n    [-n,-n,0]\n    )))\n\nQprime = Quiver(Q.matrix)\n\nfor i in [1..maxNodes]:\n    Qprime = Quiver(constructionOf1ForklessPart2(Qprime.matrix, n))\n    for j in [2..Qprime.matrix.ncols() - 1]:\n        if not(isFork(Qprime.mutate([j]).matrix)):\n               print(\"You're wrong Ty\")\n    Qmu1 = Qprime.mutate([1]).matrix\n    QmuN = Qprime.mutate([Qprime.matrix.ncols()]).matrix\n    \n    for j in [1..Qprime.matrix.ncols() - 1]:\n        Qmu1 = swapNodes(Qmu1, j, j+1)\n    for j in range(Qprime.matrix.ncols() - 1,0,-1):\n        QmuN = swapNodes(QmuN, j, j+1)\n        \n    print(i + 3, Qprime.matrix == Qmu1, Qprime.matrix == QmuN)","output":{"0":{"name":"stdout","output_type":"stream","text":"4 True True\n5 True True\n6 True True\n7 True True\n8 True True\n"},"1":{"name":"stdout","output_type":"stream","text":"9 True True\n10 True True\n11 True True\n"},"10":{"name":"stdout","output_type":"stream","text":"23 True True\n"},"2":{"name":"stdout","output_type":"stream","text":"12 True True\n13 True True\n14 True True\n"},"3":{"name":"stdout","output_type":"stream","text":"15 True True\n16 True True\n"},"4":{"name":"stdout","output_type":"stream","text":"17 True True\n"},"5":{"name":"stdout","output_type":"stream","text":"18 True True\n"},"6":{"name":"stdout","output_type":"stream","text":"19 True True\n"},"7":{"name":"stdout","output_type":"stream","text":"20 True True\n"},"8":{"name":"stdout","output_type":"stream","text":"21 True True\n"},"9":{"name":"stdout","output_type":"stream","text":"22 True True\n"}},"pos":9,"type":"cell"}
{"cell_type":"code","id":"a460e6","input":"## issue: Weird thing where if you look in terms of outward and inward relations, the quivers are the same with a \n## 1-to-1 mapping of nodes but the matrix representations are fundementally different\n\nload(\"quivers.sage\")\n\nn=5\nm=4\n\nQ = Quiver(matrix(([0,-m],[m,0])))\nQ = constructionOf1ForklessPart3(Q.matrix, n, m)\nQ = Quiver(constructionOf1ForklessPart3(Q, n, m))\nprint(Q.matrix)\n\nprint(isFork(Q.matrix))\ndisplayQuiver(Q.matrix)\n\nfor i in [1..6]:\n    if not(isFork(Q.mutate([i]).matrix)):\n        print(i)\n\nQmu1 = Q.mutate([1]).matrix\nQmu1 = swapNodes(Qmu1, 1, 6)\nQmu1 = swapNodes(Qmu1, 2, 3)\nQmu1 = swapNodes(Qmu1, 3, 5)\nQmu1 = swapNodes(Qmu1, 4, 5)\nQmu1 = swapNodes(Qmu1, 5, 6)\nprint(Qmu1)\nprint(Qmu1 == Q.matrix)\nprint()\n\n## definately doesnt work for mu5 as there is no node after mutation with 2 predecessors with 5 arrows\nQmu5 = Q.mutate([5]).matrix\nQmu5 = swapNodes(Qmu1, 1, 5)\nQmu5 = swapNodes(Qmu1, 1, 1)\nprint(Qmu5)\nprint(Qmu5 == Q.matrix, Qmu3 == Qmu1)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 0 -4 -5 -5 -5 -5]\n[ 4  0 -5  5 -5  5]\n[ 5  5  0  4 -5  5]\n[ 5 -5 -4  0 -5  5]\n[ 5  5  5  5  0  4]\n[ 5 -5 -5 -5 -4  0]\n0\n"},"1":{"data":{"image/png":"ce8d64a60b590d6abc7cadca3d7f412d07f8a55d","text/plain":"Graphics object consisting of 37 graphics primitives"},"exec_count":0,"output_type":"execute_result"},"2":{"name":"stdout","output_type":"stream","text":"1\n5\n[ 0 -5 -4 -5 -5 -5]\n[ 5  0 -5  5 -5  4]\n[ 4  5  0  5 -5  5]\n[ 5 -5 -5  0 -4  5]\n[ 5  5  5  4  0  5]\n[ 5 -4 -5 -5 -5  0]\nFalse\n\n[ 0 -4 -5 -5  5 -5]\n[ 4  0 -5  5  5  5]\n[ 5  5  0  4  5  5]\n[ 5 -5 -4  0  5  5]\n[-5 -5 -5 -5  0 -4]\n[ 5 -5 -5 -5  4  0]\n"}},"pos":11,"type":"cell"}
{"cell_type":"code","id":"b9e5c5","input":"## messing around with 2forkless part as 1 forkless part has me weared out rn\nload(\"quivers.sage\")\n\nm = 3\nn = 4\no = 5\n\nQ = Quiver(matrix(([0,o,-n,-o],\n                   [-o,0,m,n],\n                   [n,-m,0,m],\n                   [o,-n,-m,0])))\nprint(isFork(Q.matrix))\n\nfor i in [1..4]:\n    Qprime = Q.mutate([i])\n    if not(isFork(Qprime.matrix)):\n        print(Qprime.matrix)\n        \n    print(i)","output":{"0":{"name":"stdout","output_type":"stream","text":"0\n1\n2\n3\n4\n"}},"pos":14,"type":"cell"}
{"cell_type":"code","id":"caeacd","input":"# testing construction #4\nload(\"quivers.sage\")\n\nnumNodes = 10\nn = 5\nm = 4\n\nQ = Quiver(matrix(([0,-m],[m,0])))\nQ = Quiver(constructionOf1ForklessPart4(Q.matrix, n, (m + 2)))\n\nfor i in [1..numNodes]:\n    \n    print(Q.isFork)\n    \n    print(i, '- 0')\n    for j in [1..Q.matrix.ncols()]:\n        if not(isFork(Q.mutate([j]).matrix)):\n            print(j)\n            \n    Q = Quiver(constructionOf1ForklessPart4(Q.matrix, n, (m + 2 *((i+1)%2))))\n    Qprime = Q.subquiverRemoveVertex(2*i + 4)\n    \n    print(i, '- 1')\n    for j in [1..Qprime.matrix.ncols()]:\n        if not(isFork(Qprime.mutate([j]).matrix)):\n            print(j)\n            \n    Qprime = Q.subquiverRemoveVertex(2*i + 3)\n    \n    print(i, '- 2')\n    for j in [1..Qprime.matrix.ncols()]:\n        if not(isFork(Qprime.mutate([j]).matrix)):\n            print(j)\n            \n    Qprime = Q.subquiverRemoveVertex(1)\n    print(i, '- 3')\n    for j in [1..Qprime.matrix.ncols()]:\n        if not(isFork(Qprime.mutate([j]).matrix)):\n            print(j)\n    \n    print()\n    ## issue can remove any vertex and stays 1 forkless part, thus I am quite confused as where to go with this\n    ## this is the 4th construction process, I conjectured infinately many, still unsure of found near all 1 forkless part quivers","output":{"0":{"name":"stdout","output_type":"stream","text":"False\n1 - 0\n1 - 1\n1 - 2\n1 - 3\n\nFalse\n2 - 0\n2 - 1\n2 - 2\n2 - 3\n\nFalse\n3 - 0\n3 - 1\n3 - 2\n"},"1":{"name":"stdout","output_type":"stream","text":"3 - 3\n\nFalse\n4 - 0\n4 - 1\n4 - 2\n4 - 3\n"},"10":{"name":"stdout","output_type":"stream","text":"8 - 3\n"},"11":{"name":"stdout","output_type":"stream","text":"\nFalse\n9 - 0\n"},"12":{"name":"stdout","output_type":"stream","text":"9 - 1\n"},"13":{"name":"stdout","output_type":"stream","text":"9 - 2\n"},"14":{"name":"stdout","output_type":"stream","text":"9 - 3\n"},"15":{"name":"stdout","output_type":"stream","text":"\nFalse\n10 - 0\n"},"16":{"name":"stdout","output_type":"stream","text":"10 - 1\n"},"17":{"name":"stdout","output_type":"stream","text":"10 - 2\n"},"18":{"name":"stdout","output_type":"stream","text":"10 - 3\n"},"19":{"name":"stdout","output_type":"stream","text":"\n"},"2":{"name":"stdout","output_type":"stream","text":"\nFalse\n5 - 0\n5 - 1\n5 - 2\n5 - 3\n"},"3":{"name":"stdout","output_type":"stream","text":"\nFalse\n6 - 0\n6 - 1\n"},"4":{"name":"stdout","output_type":"stream","text":"6 - 2\n6 - 3\n"},"5":{"name":"stdout","output_type":"stream","text":"\nFalse\n7 - 0\n7 - 1\n"},"6":{"name":"stdout","output_type":"stream","text":"7 - 2\n"},"7":{"name":"stdout","output_type":"stream","text":"7 - 3\n\n"},"8":{"name":"stdout","output_type":"stream","text":"False\n8 - 0\n8 - 1\n"},"9":{"name":"stdout","output_type":"stream","text":"8 - 2\n"}},"pos":13,"type":"cell"}
{"cell_type":"code","id":"d7a053","input":"load(\"quivers.sage\")\nM = matrix(([0,2,0,2],[-2,0,2,0],[0,-2,0,2],[-2,0,-2,0]))\nQ = Quiver(M)\nG = Q.forklessPart(3)\nG.plot(edge_labels = True, vertex_labels = False) # Draws the labelled forkless mutation graph for our quiver \n","output":{"0":{"name":"stdout","output_type":"stream","text":"2 mutations deep\n3 mutations deep\n"},"1":{"data":{"image/png":"6d0dd2646407118dff6ee88ec722a03f2eb4d029","text/plain":"Graphics object consisting of 57 graphics primitives"},"exec_count":0,"output_type":"execute_result"}},"pos":5,"scrolled":true,"type":"cell"}
{"cell_type":"code","id":"eca0e9","input":"","pos":3,"type":"cell"}
{"id":0,"time":1710821634577,"type":"user"}
{"last_load":1710821729396,"type":"file"}